# Tulk

### A toy unix like kernel


## 概述

Tulk是一个简单的类unix的内核。主要参考```MIT 6.828 JOS``` 内核源码和```Mr.James' tutorial```开发完成。
代码量4000+，总体比较简单，帮助理解操作系统课程的一些抽象概念，因此是一个```玩具```内核。

## 启动

- Grub

本着不重复发明轮子的原则，开机启动我们直接使用了grub作为开机引导。
关于grub，可以参考[这里](http://www.cnblogs.com/chio/archive/2008/01/01/1022430.html)，这一部分内容其实是有一定的固定模式。

我们将一个内核的开始地址 _start 传递给链接器。链接器进行重定位。
在链接器脚本文件中规定init相关的代码在低地址区域，真正的代码在高地址区域。为什么这么做？因为开始的时候我们没有开启虚拟内存机制，使用的就是物理内存地址。

然后在低地址区域，需要建立一个临时的栈，用来执行开启分页之前的程序。

grub代码执行之返回的是一个结构体的指针，这个结构体描述了整个内核的一些整体特征。我们将他保存起来，在内核的低地址区域开启一个1K的栈。并且调用kern_entry。

- 临时页表

kern_entry的重要特点就是开启了临时页表。页表目录和买个页表项的大小是1K，我们将他们放在低地址的区域。
这个临时页表，我们需要达到这样一个目的：

3G+1M+的内存引用和1M+的内存引用同时有效，即指向低地址区域。

## 显示

这里我们使用的是VGA显示。

```
// VGA 的显示缓冲的起点是 0xB8000
static uint16_t *video_memory = (uint16_t *)(0xB8000 + KERNBASE); 
// 这里加上了3G是因为后面我们将内核的地址映射到了+3GB处的位置
```

关于vga显示，基本上就是操作对应的内存区域，内存和显示器的对应关系，详见代码```./drivers/console.c```。

## init_debug

获取的是grub提供的elf的信息。

内存布局大致是这样的：
```
____________________________
| header | header |   ...  |
----------------------------
```
每个结构都是一个elf_section_header_t，grub提供的信息有：

开始的header的地址，以及字符串相关的header的地址。

每个header中至少有如下信息：

这个header的名字是什么，一般只给出相对于字符串内存块的偏移。
这个header在内存中的真正的位置，内存中的长度。

我们只关心如下的部分：

strtab，symtab，额外保存env的相关信息。

## gdt

全局描述符表格。
相当于分段机制，但是这里的分段是不彻底的分段，因为所有的段都混在了一块。只不过有访问权限的限制。


## idt

中断描述符表格。
这个内核不支持中断嵌套处理。
因此每次处理中断的时候需要先关闭中断。

每个中断处理函数是不同的，但是由于CPU会对每个中断进行一个预处理，为了统一过程，需要将中断处理函数进行包装。

每个中断处理函数分为两种，是不是将error_code压入栈中。
然后转到响应的C语言中定义的错误处理函数。
中断处理函数都在内核栈中。

这里的中断指的是笼统的称呼，实际上的中断分为 interrupt 和 exception。

在IA32架构上, 中断是异步事件, 是硬件设备通过中断控制器对CPU发出的中断请求. 异常是同步事件, 由系统本身检测到,  如断点指令INT 3, 以及一些软件执行异常如除0等. 中断和异常门都放在IDT中, 其中中断的type字段是0xFF, 而异常是0xFE.



## pmm

物理内存管理。
实际的物理内存是我们仅仅使用1M~附近的一些内存，低地址区域内存，高地址我们都没有使用，这里我们放弃使用低地址部分。从没有使用的部分开始。也就是kern_end，对齐到PGSIZE，每个PGSIZE，想象成一个逻辑块，将按照地址从小到达放到一个stack中，然后逆转这个栈（为什么需要逆转，参考代码pmm.c），每个逻辑块维护的是struct pageinfo这个结构。

这一部分实际上是虚拟内存的基础。

## vmm

虚拟内存管理。

二级页表。map_region的主要作用就是给定一个物理空间的开始地址，一个虚拟空间的开始地址和映射的大小，将一个物理地址映射到虚拟空间。
然后第一层，也就是内核页表目录，是固定的，页表项在合适的时候进行开辟，减少内存空间的消耗。



## heap

堆的地址空间是从0xD0000000开始的，内存的分配和释放，采用的是可变分区方式，具体的实现方式可以参考CS:APP2e。

## environment

进程相关。

我们只实现了内核级别的进程，用户级别的进程没有实现。将正在执行的进程排成一个链，每个进程维护下面的数据结构。


```C
struct Env {
    struct context_t context;           // 进程切换需要的上下文信息
	struct Env *next_env;
	envid_t env_id;			            // Unique environment identifier
	envid_t env_parent_id;		        // env_id of this env's parent
	enum EnvType env_type;		        // Indicates special system environments
	volatile unsigned env_status;		// Status of the environment
	uint32_t env_runs;		            // Number of times environment has run
	// Address space
	pde_t *env_pgdir;		            // 用户进程
	bool bg;                            // 当前是不是后台运行
};

// 内核进程的上下文切换保存的信息
struct context_t {
    uint32_t esp;
    uint32_t ebp;
    uint32_t ebx;
    uint32_t esi;
    uint32_t edi;
    uint32_t eflags;
};

```


系统最多可以同时运行的进程为1024个，维护一个结构体数组。

同样使用一个stack来保存没有使用的哪些env的位置。
同时为每个进程指定对应的栈的空间。

- 如何建立并开启一个进程。

因为我们保存了每个进程的text信息，因此我们就能设置eip指针，又因为我们知道每个进程的栈的位置，那么就知道了esp的大小。
其他的env相关的参数使用默认即可，注意特别的应该设置可中断这个特征，并且将这个进程插入到单向循环链表的结束位置。

- 如何销毁一个进程。

将进程设置为不可调度的，并且回收进程相关的资源即可。

## Timer

定时器。
定时器的设置有一定固定的模式，操作寄存器然后注册中断处理函数。
中断处理函数就是简单的进程调度。


## keyboard

键盘驱动。
键盘驱动函数的调用仅仅发生在按键被按下之后，这个时候将按键的内容放到全局buffer里面。


## systemcall

系统调用。
理论上，系统调用是进程与内核通信的唯一通道。
进程将参数放到各个寄存器，然后通过内存的kern_sys_call调用相关内核函数，然后将返回的结果放到eax寄存器中。


## schedule

进程调度
进程调度主要的部分实现的是进程之间的切换。将当前的环境保存起来，然后将下一个进程的寄存器等参数放到当前的环境中。
具体可以参考swith.s的汇编代码。

## more details

由于多个进程并发执行，每个进程可能同时使用IO（这里的IO仅仅是指与用户进行屏幕上的交互），每个进程初始化有前台状态和后台状态。
当前系统，只有前台进程能使用IO，后台进程如果使用IO，将会被阻塞，只有手动将后台进程放到前台，才能解除这种阻塞。
根据这种推断，最多只有一个前台进程处于运行状态。另外进程可能处于暂停状态。




